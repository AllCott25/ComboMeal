function combineVessels(v1, v2) {
    // Check if hint is active before creating any new vessels
    let hintActive = showingHint && hintVessel;
    
    // Case 1: Both vessels are base ingredients (white vessels)
    if (v1.ingredients.length > 0 && v2.ingredients.length > 0 && v1.complete_combinations.length === 0 && v2.complete_combinations.length === 0) {
      let U = [...new Set([...v1.ingredients, ...v2.ingredients])];
      
      // Special handling for hint: If all ingredients are part of the hint
        if (hintActive) {
          // Check if all ingredients are required for the hint
          let allIngredientsInHint = U.every(ing => hintVessel.required.includes(ing));
          
          // Check if any of these ingredients are already collected in the hint
          let anyAlreadyCollected = U.some(ing => hintVessel.collected.includes(ing));
          
          // If all ingredients are part of the hint and none are already collected,
        // we should add them directly to the hint vessel instead of creating a new vessel
          if (allIngredientsInHint && !anyAlreadyCollected) {
          console.log(`Adding ingredients directly to hint: ${U.join(', ')}`);
          
          // Add all ingredients to the hint vessel
          for (let ing of U) {
            hintVessel.addIngredient(ing);
          }
          
          // Create animations directly from each original vessel to the hint vessel
          createCombineAnimation(v1.x, v1.y, v1.color, hintVessel.x, hintVessel.y);
          createCombineAnimation(v2.x, v2.y, v2.color, hintVessel.x, hintVessel.y);
          
          // Add red moves to history - one for each ingredient (or at least one if it was a combination)
          // This ensures we count the proper number of turns when adding multiple ingredients at once
          let numIngredientsAdded = Math.max(1, U.length);
          // Red counters have been removed
          // for (let j = 0; j < numIngredientsAdded; j++) {
          //   moveHistory.push('#FF5252');
          // }
          
          // Check if hint is complete
          if (hintVessel.isComplete()) {
            // Convert hint to regular vessel
            let newVessel = hintVessel.toVessel();
            
            // Reset hint
            hintVessel = null;
            showingHint = false;
            
            // Return the new vessel
            return newVessel;
          }
          
          // Return null to indicate no new vessel should be created
          // The ingredients were added directly to the hint vessel
          return null;
        }
      }
      
      // Check if this combination matches or partially matches any recipe
      let C_candidates = intermediate_combinations.filter(C => {
        // Check if there's any overlap between the required ingredients and our combined set
        let overlap = C.required.filter(ing => U.includes(ing));
        // Only consider it a match if ALL ingredients in U are part of the recipe
        // AND there's at least one ingredient from the recipe in U
        return overlap.length > 0 && U.every(ing => C.required.includes(ing));
      });
      
      // Only create a new vessel if we have valid recipe candidates
      if (C_candidates.length > 0) {
        // Calculate appropriate vessel dimensions based on play area size
        const vesselWidth = Math.max(playAreaWidth * 0.25, 150); // 25% of play area width, min 150px
        const vesselHeight = vesselWidth * 0.5; // Maintain aspect ratio
        
        // Create a new vessel (yellow or green) with relative dimensions
        let new_v = new Vessel(U, [], null, 'yellow', (v1.x + v2.x) / 2, (v1.y + v2.y) / 2, vesselWidth, vesselHeight);
        
        let C = C_candidates[0];
        
        // Check if we have all required ingredients for this combination
        // Modified: Only check if all required ingredients are present, not requiring exact length match
        if (C.required.every(ing => U.includes(ing))) {
          // Only turn green if not part of an active hint
          if (!hintActive || C.name !== hintVessel.name) {
          new_v.name = C.name;
          new_v.color = COLORS.green; // Use COLORS.green instead of string 'green'
            new_v.ingredients = []; // Clear ingredients since this is now a complete combination
            
            // Set the verb from the combination and display it
            for (let combo of intermediate_combinations) {
              if (combo.name === C.name && combo.verb) {
                new_v.verb = combo.verb;
                new_v.verbDisplayTime = 120; // Display for 120 frames (about 2 seconds)
                break;
              }
            }
            
            // Add to completedGreenVessels when creating a green vessel - APlasker
            if (!completedGreenVessels.some(vessel => vessel.name === C.name)) {
              completedGreenVessels.push({name: C.name});
            }
            
            // Clear activePartialCombo since we completed the combination
            activePartialCombo = null;
            
            // Remove from partialCombinations array since it's now complete
            const index = partialCombinations.indexOf(C.name);
            if (index > -1) {
              partialCombinations.splice(index, 1);
              console.log(`Removed ${C.name} from partialCombinations:`, partialCombinations);
            }
            
            console.log(`Created green vessel for ${C.name} with ingredients: ${U.join(', ')}`);
          }
        } else {
          console.log(`Created yellow vessel with ingredients: ${U.join(', ')}`);
          console.log(`Missing ingredients for ${C.name}: ${C.required.filter(ing => !U.includes(ing)).join(', ')}`);
          
          // Track this as the active partial combination
          activePartialCombo = C.name;
          
          // Add to partialCombinations array if not already in it
          if (!partialCombinations.includes(C.name)) {
            partialCombinations.push(C.name);
            console.log(`Added ${C.name} to partialCombinations:`, partialCombinations);
          }
          
          console.log(`Set activePartialCombo to: ${activePartialCombo}`);
        }
        
        return new_v;
      } else {
        // No matching recipe, don't create a vessel
        console.log(`Cannot combine unrelated ingredients: ${U.join(', ')}`);
        // Clear activePartialCombo since we don't have a valid partial match
        activePartialCombo = null;
        return null;
      }
    } 
    // Case 2: Both vessels are completed combinations (green vessels)
    else if ((v1.name || v1.complete_combinations.length > 0) && (v2.name || v2.complete_combinations.length > 0)) {
      // Handle combining completed combinations (green vessels)
      let set1 = v1.complete_combinations.length > 0 ? v1.complete_combinations : (v1.name ? [v1.name] : []);
      let set2 = v2.complete_combinations.length > 0 ? v2.complete_combinations : (v2.name ? [v2.name] : []);
      let U = [...new Set([...set1, ...set2])];
      
      console.log("Combining completed combinations:", U);
      
      // Find the combinations in our intermediate_combinations array
      let combo1 = null;
      let combo2 = null;
      
      // Find the combination objects for the vessels being combined
      for (let name of set1) {
        const found = intermediate_combinations.find(c => c.name === name);
        if (found) {
          combo1 = found;
          break;
        }
      }
      
      for (let name of set2) {
        const found = intermediate_combinations.find(c => c.name === name);
        if (found) {
          combo2 = found;
          break;
        }
      }
      
      console.log("Combo 1:", combo1);
      console.log("Combo 2:", combo2);
      
      // Check if both combinations have the same parent_combo
      if (combo1 && combo2 && combo1.parent_combo && combo2.parent_combo && 
          combo1.parent_combo === combo2.parent_combo) {
        
        console.log("Both combinations have the same parent:", combo1.parent_combo);
        
        // Find the parent combination
        const parentCombo = intermediate_combinations.find(c => c.combo_id === combo1.parent_combo) || 
                           (final_combination.combo_id === combo1.parent_combo ? final_combination : null);
        
        if (parentCombo) {
          console.log("Found parent combination:", parentCombo.name);
          
          // Calculate appropriate vessel dimensions based on play area size
          const vesselWidth = Math.max(playAreaWidth * 0.25, 150); // 25% of play area width, min 150px
          const vesselHeight = vesselWidth * 0.5; // Maintain aspect ratio
          
          // Create a new vessel for the parent combination with relative dimensions
          let new_v = new Vessel([], U, null, 'yellow', (v1.x + v2.x) / 2, (v1.y + v2.y) / 2, vesselWidth, vesselHeight);
          
          // Check if we have all required components for the parent combination
          // Get all combinations that have this parent
          const requiredCombos = intermediate_combinations
            .filter(c => c.parent_combo === parentCombo.combo_id)
            .map(c => c.name);
            
          console.log("Required combinations for parent:", requiredCombos);
          
          // Check if we have all the required combinations
          const hasAllRequired = requiredCombos.every(name => U.includes(name));
          
          if (hasAllRequired) {
            new_v.name = parentCombo.name;
            new_v.color = COLORS.green; // Use our explicit green color
            new_v.complete_combinations = []; // Clear since this is now a complete combination
            
            // Set the verb from the parent combination and display it
            if (parentCombo.verb) {
              new_v.verb = parentCombo.verb;
              new_v.verbDisplayTime = 120; // Display for 120 frames (about 2 seconds)
            }
            
            // Add parent combo to completed vessels - APlasker
            if (!completedGreenVessels.some(vessel => vessel.name === parentCombo.name)) {
              completedGreenVessels.push({name: parentCombo.name});
            }
            
            console.log(`Created green vessel for ${parentCombo.name}`);
          } else {
            console.log(`Created yellow vessel with combinations: ${U.join(', ')}`);
            console.log(`Missing combinations for ${parentCombo.name}: ${requiredCombos.filter(name => !U.includes(name)).join(', ')}`);
          }
          
          return new_v;
        }
      }
      
      // If we don't have parent_combo information or they don't match, check if they're part of the final recipe
      // Only allow combinations if they're part of the final recipe's required combinations
      let finalRecipeComponents = final_combination.required || [];
      
      // Check if both vessels contain combinations that are part of the final recipe
      let v1ContainsFinalComponent = set1.some(name => finalRecipeComponents.includes(name));
      let v2ContainsFinalComponent = set2.some(name => finalRecipeComponents.includes(name));
      
      if (v1ContainsFinalComponent && v2ContainsFinalComponent) {
        console.log("Both vessels contain components of the final recipe");
        
        // Calculate appropriate vessel dimensions based on play area size
        const vesselWidth = Math.max(playAreaWidth * 0.25, 150); // 25% of play area width, min 150px
        const vesselHeight = vesselWidth * 0.5; // Maintain aspect ratio
        
        // Create a new vessel for the combined components with relative dimensions
        let new_v = new Vessel([], U, null, 'yellow', (v1.x + v2.x) / 2, (v1.y + v2.y) / 2, vesselWidth, vesselHeight);
        
        // Check if we have all required components for the final combination
        if (finalRecipeComponents.every(name => U.includes(name))) {
          new_v.name = final_combination.name;
          new_v.color = COLORS.green; // Use our explicit green color
          new_v.complete_combinations = []; // Clear since this is the final combination
          
          // Set the verb from the final combination and display it
          if (final_combination.verb) {
            new_v.verb = final_combination.verb;
            new_v.verbDisplayTime = 120; // Display for 120 frames (about 2 seconds)
            console.log("Setting verb for final combo:", new_v.verb);
          } else {
            // Add a fallback verb if none exists in the data
            new_v.verb = "Prepare";
            new_v.verbDisplayTime = 120;
            console.log("Using fallback verb for final combo");
          }
          
          // Add final combo to completedGreenVessels too - APlasker
          if (!completedGreenVessels.some(vessel => vessel.name === final_combination.name)) {
            completedGreenVessels.push({name: final_combination.name});
          }
          
          console.log(`Created green vessel for final combination ${final_combination.name}`);
        } else {
          console.log(`Created yellow vessel with combinations: ${U.join(', ')}`);
          console.log(`Missing combinations for ${final_combination.name}: ${finalRecipeComponents.filter(name => !U.includes(name)).join(', ')}`);
        }
        
        return new_v;
      } else {
        // If the combinations don't have the same parent and aren't both part of the final recipe,
        // don't allow them to be combined
        console.log("Invalid combination: Combinations don't share the same parent and aren't both part of the final recipe");
        return null;
      }
    }
    // Case 3: Mixing a base ingredient (white vessel) with a completed combination (green/yellow vessel)
    else if ((v1.ingredients.length > 0 && (v2.name || v2.complete_combinations.length > 0)) || 
             (v2.ingredients.length > 0 && (v1.name || v1.complete_combinations.length > 0))) {
      
      // Determine which vessel is the base ingredient and which is the combination
      let baseVessel = v1.ingredients.length > 0 ? v1 : v2;
      let comboVessel = v1.ingredients.length > 0 ? v2 : v1;
      
      // Get the base ingredient name(s)
      let baseIngredients = baseVessel.ingredients;
      
      // Get the completed combinations
      let completedCombos = comboVessel.complete_combinations.length > 0 ? 
                            comboVessel.complete_combinations : 
                            (comboVessel.name ? [comboVessel.name] : []);
      
      // Check if this combination is valid for any recipe
      let validCombination = false;
      let targetRecipe = null;
      
      // First, check if this is a valid combination for the final recipe
      if (final_combination.required.some(req => completedCombos.includes(req))) {
        // This is a valid combination for the final recipe
        // Check if any of the base ingredients are also required for the final recipe
        if (baseIngredients.some(ing => final_combination.required.includes(ing))) {
          validCombination = true;
          targetRecipe = final_combination;
        }
      }
      
      // If not valid for the final recipe, check intermediate combinations
      if (!validCombination) {
        // Check each intermediate combination
        for (let combo of intermediate_combinations) {
          // Check if the base ingredients are part of this recipe
          if (baseIngredients.every(ing => combo.required.includes(ing))) {
            // Check if any of the completed combinations are also part of this recipe
            // This is a special case where a completed combination might be a component of another recipe
            if (completedCombos.some(c => {
              // Find the intermediate combination with this name
              let matchingCombo = intermediate_combinations.find(ic => ic.name === c);
              // Check if all ingredients of this combination are part of the target recipe
              return matchingCombo && matchingCombo.required.every(ing => combo.required.includes(ing));
            })) {
              validCombination = true;
              targetRecipe = combo;
              break;
            }
          }
        }
      }
      
      // Only proceed if this is a valid combination
      if (validCombination && targetRecipe) {
        // Create a combined set of all components
        let allComponents = [];
        
        // If we're building toward the final recipe, use the combination names
        if (targetRecipe === final_combination) {
          allComponents = [...baseIngredients, ...completedCombos];
        } else {
          // For intermediate recipes, we need to extract the ingredients
          let allIngredients = [...baseIngredients];
          
          // Add ingredients from completed combinations
          for (let combo of completedCombos) {
            let matchingCombo = intermediate_combinations.find(ic => ic.name === combo);
            if (matchingCombo) {
              allIngredients = [...allIngredients, ...matchingCombo.required];
            }
          }
          
          // Remove duplicates
          allIngredients = [...new Set(allIngredients)];
          
          // Only keep ingredients that are part of the target recipe
          allIngredients = allIngredients.filter(ing => targetRecipe.required.includes(ing));
          
          allComponents = allIngredients;
        }
        
        // Create a yellow vessel for the partial combination
        let new_v;
        
        if (targetRecipe === final_combination) {
          // Calculate appropriate vessel dimensions based on play area size
          const vesselWidth = Math.max(playAreaWidth * 0.25, 150); // 25% of play area width, min 150px
          const vesselHeight = vesselWidth * 0.5; // Maintain aspect ratio
          
          // For final recipe, store combination names with relative dimensions
          new_v = new Vessel([], allComponents, null, 'yellow', (v1.x + v2.x) / 2, (v1.y + v2.y) / 2, vesselWidth, vesselHeight);
        } else {
          // Calculate appropriate vessel dimensions based on play area size
          const vesselWidth = Math.max(playAreaWidth * 0.25, 150); // 25% of play area width, min 150px
          const vesselHeight = vesselWidth * 0.5; // Maintain aspect ratio
          
          // For intermediate recipes, store ingredients with relative dimensions
          new_v = new Vessel(allComponents, [], null, 'yellow', (v1.x + v2.x) / 2, (v1.y + v2.y) / 2, vesselWidth, vesselHeight);
        }
        
        // Check if we have all required components for the target recipe
        let hasAllRequired = false;
        
        if (targetRecipe === final_combination) {
          // For final recipe, check if all required combinations are present
          hasAllRequired = targetRecipe.required.every(req => allComponents.includes(req));
        } else {
          // For intermediate recipes, check if all required ingredients are present
          hasAllRequired = targetRecipe.required.length === allComponents.length && 
                           targetRecipe.required.every(req => allComponents.includes(req));
        }
        
        if (hasAllRequired) {
          new_v.name = targetRecipe.name;
          new_v.color = COLORS.green; // Use our explicit green color
          
          if (targetRecipe === final_combination) {
            new_v.complete_combinations = []; // Clear since this is the final combination
            
            // Set the verb from the final combination and display it
            if (final_combination.verb) {
              new_v.verb = final_combination.verb;
              new_v.verbDisplayTime = 120; // Display for 120 frames (about 2 seconds)
            }
          } else {
            new_v.ingredients = []; // Clear ingredients since this is a complete intermediate combination
            
            // Set the verb from the intermediate combination and display it
            for (let combo of intermediate_combinations) {
              if (combo.name === targetRecipe.name && combo.verb) {
                new_v.verb = combo.verb;
                new_v.verbDisplayTime = 120; // Display for 120 frames (about 2 seconds)
                console.log("Setting verb for intermediate combo:", new_v.verb);
                break;
              }
            }
            
            // If no verb was found, use a fallback
            if (!new_v.verb) {
              new_v.verb = "Mix";
              new_v.verbDisplayTime = 120;
              console.log("Using fallback verb for intermediate combo");
            }
          }
          
          console.log(`Created green vessel for ${targetRecipe.name}`);
        } else {
          if (targetRecipe === final_combination) {
            console.log(`Created yellow vessel with combinations for final recipe`);
            console.log(`Missing combinations: ${targetRecipe.required.filter(req => !allComponents.includes(req)).join(', ')}`);
          } else {
            console.log(`Created yellow vessel with ingredients for ${targetRecipe.name}`);
            console.log(`Missing ingredients: ${targetRecipe.required.filter(req => !allComponents.includes(req)).join(', ')}`);
          }
        }
        
        return new_v;
      } else {
        console.log("Invalid combination of base ingredient and completed combination");
        return null;
      }
    }
    
    return null;
  }
  
  // Function to show a hint
  function showHint() {
    if (!showingHint && !gameWon) {
      // Reset inactivity reminder count when player uses hint
      inactivityReminderCount = 0;
      
      // Update last action time
      lastAction = frameCount;
      
      // Check if only the final combination remains
      if (isOnlyFinalComboRemaining()) {
        console.log("Only final combination remains, hint disabled");
        return; // Exit early
      }
      
      hintCount++; // Increment hint counter
      
      // Add a bright blue counter for creating a hint vessel
      moveHistory.push(COLORS.vesselHint); // Red color for hint creation (matching hint vessels)
      turnCounter++; // Increment turn counter for hint creation
      
      
      // Find combinations that have been completed
      let completedCombos = vessels
        .filter(v => v.name !== null)
        .map(v => v.name);
      
      // Also check for combinations that are part of partial combinations
      // These are combinations that are in the complete_combinations array of any vessel
      let partialCompletedCombos = [];
      vessels.forEach(v => {
        if (v.complete_combinations && v.complete_combinations.length > 0) {
          partialCompletedCombos.push(...v.complete_combinations);
        }
      });
      
      // Combine both lists to get all combinations that shouldn't be offered as hints
      let allCompletedCombos = [...new Set([...completedCombos, ...partialCompletedCombos])];
      
      console.log("All completed combinations (including partial):", allCompletedCombos);
      
      // Get all ingredients currently visible on the board
      let visibleIngredients = [];
      vessels.forEach(v => {
        visibleIngredients.push(...v.ingredients);
      });
      
      console.log("Visible ingredients on board:", visibleIngredients);
      console.log("Completed combinations:", completedCombos);
      
      // Calculate which combinations can be made with visible ingredients
      let possibleCombos = [];
      
      // Check all intermediate combinations that aren't completed yet
      let availableCombos = intermediate_combinations.filter(combo => 
        !allCompletedCombos.includes(combo.name));
      
      // Filter out combinations that require completed combinations as ingredients
      availableCombos = availableCombos.filter(combo => {
        // Check if any of the required ingredients are completed combinations
        return !combo.required.some(ingredient => completedCombos.includes(ingredient));
      });
      
      console.log("Available combinations after filtering out those requiring completed combos:", 
        availableCombos.map(c => c.name));
      
      // If all intermediate combinations are done, check final combination
      if (availableCombos.length === 0 && !completedCombos.includes(final_combination.name)) {
        // For the final combination, we actually want to use completed combinations
        // But only if not all required combinations are completed yet
        let finalComboRequiredCount = final_combination.required.length;
        let finalComboCompletedCount = final_combination.required.filter(req => 
          completedCombos.includes(req)).length;
        
        if (finalComboCompletedCount > 0 && finalComboCompletedCount < finalComboRequiredCount) {
          availableCombos = [final_combination];
        }
      }
      
      // For each available combination, calculate what percentage of its ingredients are visible
      availableCombos.forEach(combo => {
        let requiredCount = combo.required.length;
        let availableCount = 0;
        
        // Count how many required ingredients are visible on the board
        combo.required.forEach(ing => {
          // For the final combination, completed combinations count as available
          if (combo === final_combination && completedCombos.includes(ing)) {
            availableCount++;
          } 
          // For other combinations, only count visible base ingredients
          else if (visibleIngredients.includes(ing)) {
            availableCount++;
          }
        });
        
        // Calculate percentage of available ingredients
        let percentage = availableCount / requiredCount;
        
        // Only consider combinations where at least one ingredient is available
        if (availableCount > 0) {
          possibleCombos.push({
            combo: combo,
            percentage: percentage,
            availableCount: availableCount
          });
        }
      });
      
      console.log("Possible combinations with percentages:", possibleCombos);
      
      // Sort by percentage (highest first), then by available count (highest first)
      possibleCombos.sort((a, b) => {
        if (b.percentage !== a.percentage) {
          return b.percentage - a.percentage;
        }
        return b.availableCount - a.availableCount;
      });
      
      // If there are possible combinations, show a hint for the one with highest percentage
      if (possibleCombos.length > 0) {
        let selectedCombo = possibleCombos[0].combo;
        hintVessel = new HintVessel(selectedCombo);
        showingHint = true;
        
        // Set the hinted combination for counter highlighting
        hintedCombo = selectedCombo.name;
        console.log(`Set hintedCombo to: ${hintedCombo}`);
        
        console.log("Created hint vessel for:", selectedCombo.name);
        console.log("Required ingredients:", selectedCombo.required);
        console.log("Percentage of ingredients available:", possibleCombos[0].percentage * 100 + "%");
        
        // Find vessels that have ingredients needed for this hint
        let vesselsToAbsorb = [];
        
        // First pass: identify vessels with ingredients that match the hint
        for (let i = 0; i < vessels.length; i++) {
          let v = vessels[i];
          
          // Only consider yellow vessels (partial combinations)
          if (v.color === COLORS.vesselYellow && v.ingredients.length > 0) {
            // Find which ingredients in this vessel are part of the hint
            let matchingIngredients = v.ingredients.filter(ing => 
              hintVessel.required.includes(ing) && !hintVessel.collected.includes(ing)
            );
            
            // Only consider vessels where ALL ingredients are part of the hint
            if (matchingIngredients.length > 0 && matchingIngredients.length === v.ingredients.length) {
              console.log(`Found partial combination with ${matchingIngredients.length} matching ingredients:`, matchingIngredients);
              vesselsToAbsorb.push({
                vessel: v,
                index: i,
                matchingIngredients: matchingIngredients
              });
            }
          }
        }
        
        // Sort vessels by number of matching ingredients (descending)
        vesselsToAbsorb.sort((a, b) => b.matchingIngredients.length - a.matchingIngredients.length);
        
        console.log(`Found ${vesselsToAbsorb.length} partial combinations with matching ingredients`);
        
        // Now absorb the vessels
        let absorbedVessels = [];
        
        for (let i = 0; i < vesselsToAbsorb.length; i++) {
          let vesselInfo = vesselsToAbsorb[i];
          let v = vesselInfo.vessel;
          
          // Skip vessels that have already been absorbed
          if (absorbedVessels.includes(v)) continue;
          
          console.log("Absorbing partial combination with ingredients:", vesselInfo.matchingIngredients.join(', '));
          
          // Add matching ingredients to the hint vessel
          let ingredientsAdded = 0;
          for (let ing of vesselInfo.matchingIngredients) {
            if (!hintVessel.collected.includes(ing)) {
              hintVessel.addIngredient(ing);
              ingredientsAdded++;
            }
          }
          
          if (ingredientsAdded > 0) {
            // Create animation from the vessel to the hint vessel
            createCombineAnimation(v.x, v.y, v.color, hintVessel.x, hintVessel.y);
            
            // Add this vessel to the absorbed list
            absorbedVessels.push(v);
            
            // Mark for removal since all ingredients were absorbed
            v.markedForRemoval = true;
            
            // Add moves to history for each absorbed ingredient
            // Red counters have been removed
            // for (let j = 0; j < ingredientsAdded; j++) {
            //   // Use the string '#FF5252' instead of COLORS.vesselHint to ensure compatibility with drawMoveHistory
            //   moveHistory.push('#FF5252');
            // }
            
            // Increment turn counter for each absorbed ingredient
            turnCounter += ingredientsAdded;
          }
        }
        
        // Remove vessels marked for removal
        vessels = vessels.filter(v => !v.markedForRemoval);
        
        // Re-arrange vessels after potential removals
        arrangeVessels();
        
        // Check if hint is complete after absorbing vessels
        if (hintVessel && hintVessel.isComplete()) {
          // Convert hint to regular vessel
          let newVessel = hintVessel.toVessel();
          vessels.push(newVessel);
          
          // Debug log to verify flow before assigning preferred row
          console.log("SHOW HINT: About to assign preferred row to new vessel");
          
          // Assign the same row as the hint vessel was in
          assignPreferredRow(newVessel, hintVessel.y);
          
          arrangeVessels();
          
          // Explicitly create a verb animation for the completed vessel
          // Check if this is the final combination
          const isFinalCombination = vessels.length === 1 && newVessel.name === final_combination.name;
          
          if (newVessel.verb && !isFinalCombination) {
            console.log("Creating immediate verb animation for hint-completed vessel:", newVessel.verb);
            // Create verb animation starting exactly at the vessel's center
            animations.push(new VerbAnimation(newVessel.verb, newVessel.x, newVessel.y, newVessel));
            // Set verbDisplayTime to 119 to prevent duplicate animations
            newVessel.verbDisplayTime = 119;
          } else if (isFinalCombination && newVessel.verb) {
            // For final combination, use the special final verb animation
            console.log("Creating final verb animation for hint-completed final vessel:", newVessel.verb);
            createFinalVerbAnimation(newVessel.verb);
            // Set verbDisplayTime to prevent duplicate animations
            newVessel.verbDisplayTime = 119;
          }
          
          // Reset hint
          hintVessel = null;
          showingHint = false;
          
          // Clear the hinted combination reference
          hintedCombo = null;
          console.log("Cleared hintedCombo as hint is complete in checkForMatchingVessels");
        }
      } else {
        console.log("No possible combinations found with visible ingredients");
        
        // If no combinations can be made with visible ingredients, fall back to a random available combo
      if (availableCombos.length > 0) {
          let randomCombo = availableCombos[Math.floor(Math.random() * availableCombos.length)];
          hintVessel = new HintVessel(randomCombo);
        showingHint = true;
        
          console.log("Falling back to random hint for:", randomCombo.name);
        }
      }
    }
  }
  
  // Function to check if any yellow vessels match the current hint
  function checkForMatchingVessels() {
    if (!hintVessel) return;
    
    // Look for yellow vessels that match required ingredients for the hint
    for (let i = vessels.length - 1; i >= 0; i--) {
      let v = vessels[i];
      
      // Check if it's a yellow vessel with ingredients that match the hint
      if (v.color === 'yellow' && v.ingredients.length > 0) {
        let matchesHint = false;
        
        // Check if all ingredients in this vessel are required for the hint
        if (v.ingredients.every(ing => hintVessel.required.includes(ing))) {
          // Check if we can add all ingredients to the hint
          let canAddAll = true;
          for (let ing of v.ingredients) {
            if (hintVessel.collected.includes(ing)) {
              canAddAll = false;
              break;
            }
          }
          
          if (canAddAll) {
            matchesHint = true;
            console.log("Adding ingredients to hint: " + v.ingredients.join(', '));
            
            // Add all ingredients to the hint vessel
            for (let ing of v.ingredients) {
              hintVessel.addIngredient(ing);
            }
            
            // Create animation
            createCombineAnimation(v.x, v.y, v.color, hintVessel.x, hintVessel.y);
            
            // Remove the vessel
            vessels.splice(i, 1);
            
            // Add red moves to history - one for each ingredient (or at least two if it was a combination)
            // This ensures we count the proper number of turns when adding multiple ingredients at once
            let numIngredientsAdded = Math.max(2, v.ingredients.length);
            // Red counters have been removed
            // for (let j = 0; j < numIngredientsAdded; j++) {
            //   moveHistory.push('#FF5252');
            // }
            
            // Increment turn counter - add one more turn since the first turn was already counted
            // when the vessel was created in mouseReleased
            turnCounter += (numIngredientsAdded - 1);
          }
        }
      }
    }
    
    // Re-arrange vessels after potential removals
    arrangeVessels();
    
    // Check if hint is complete
    if (hintVessel && hintVessel.isComplete()) {
      // Convert hint to regular vessel
      let newVessel = hintVessel.toVessel();
      vessels.push(newVessel);
      
      // Debug log to verify flow before assigning preferred row
      console.log("CHECK MATCHING VESSELS: About to assign preferred row to new vessel");
      
      // Assign the same row as the hint vessel was in
      assignPreferredRow(newVessel, hintVessel.y);
      
      // First arrange vessels to ensure they're in their final positions
      arrangeVessels();
      
      // Use the centralized helper to create the verb animation after positioning
      createVerbAnimationForVessel(newVessel);
      
      // Reset hint
      hintVessel = null;
      showingHint = false;
      
      // Clear the hinted combination reference
      hintedCombo = null;
      console.log("Cleared hintedCombo as hint is complete in checkForMatchingVessels");
    }
  }
  function isOnlyFinalComboRemaining() {
    // Case 1: Only the final dish remains
    if (vessels.length === 1 && vessels[0].name === final_combination.name) {
      return true;
    }
    
    // Case 2: All the required combinations for the final dish are present
    // Get all completed combinations
    let completedCombos = vessels
      .filter(v => v.name !== null)
      .map(v => v.name);
    
    // Also check for combinations that are part of partial combinations
    // These are combinations that are in the complete_combinations array of any vessel
    let partialCompletedCombos = [];
    vessels.forEach(v => {
      if (v.complete_combinations && v.complete_combinations.length > 0) {
        partialCompletedCombos.push(...v.complete_combinations);
      }
    });
    
    // Combine both lists to get all completed combinations
    let allCompletedCombos = [...new Set([...completedCombos, ...partialCompletedCombos])];
    
    // Check if all required combinations for the final dish are present
    // either as standalone vessels or as part of partial combinations
    let allFinalIngredientsPresent = final_combination.required.every(req => 
      allCompletedCombos.includes(req));
    
    // Check if only the required combinations for the final dish are present
    // (plus possibly some base ingredients that can't be used)
    let onlyFinalIngredientsRemain = true;
    for (let combo of completedCombos) {
      // If this is not a required ingredient for the final dish
      if (!final_combination.required.includes(combo)) {
        // And it's not a base ingredient (it's an intermediate combination)
        if (intermediate_combinations.some(ic => ic.name === combo)) {
          onlyFinalIngredientsRemain = false;
          break;
        }
      }
    }
    
    return allFinalIngredientsPresent && onlyFinalIngredientsRemain;
  }
  
  // Helper function to draw a star
  function star(x, y, radius1, radius2, npoints) {
    let angle = TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
      let sx = x + cos(a) * radius2;
      let sy = y + sin(a) * radius2;
      vertex(sx, sy);
      sx = x + cos(a + halfAngle) * radius1;
      sy = y + sin(a + halfAngle) * radius1;
      vertex(sx, sy);
    }
    endShape(CLOSE);
  }
  // Fisher-Yates shuffle algorithm to randomize vessel order
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  
  // Enhanced function to assign both preferred row and column based on drop position
  function assignPreferredRow(newVessel, dropY, dropX = mouseX) {
    // Calculate vessel sizes - must match the same calculations in arrangeVessels
    // Use relative margins exactly like in arrangeVessels
    const margin = Math.max(playAreaWidth * 0.0125, 3); // 1.25% of play area width, min 3px
    const vertical_margin = Math.max(playAreaHeight * 0.008, 2); // 0.8% of play area height, min 2px
    
    // Calculate basic vessel width and height using the exact same formula from arrangeVessels
    const basic_w = (playAreaWidth - (4 * margin)) / 3;
    const basic_h = basic_w * 0.8;
    
    // Calculate the row height using the same values as the actual arrangement
    const rowHeight = basic_h + vertical_margin;
    
    // Calculate the starting Y position - exactly matching arrangeVessels
    const startY = playAreaY + playAreaHeight * 0.2;
    
    // Calculate which row index the drop position corresponds to
    // Using Math.max to ensure we don't get negative values
    const relativeDropY = Math.max(0, dropY - startY);
    const dropRowIndex = Math.floor(relativeDropY / rowHeight);
    
    // Set preferred row, clamping to a reasonable range
    // We estimate the maximum number of rows based on vessel count
    const maxRows = Math.ceil(vessels.length / 3); // At most 3 basic vessels per row
    newVessel.preferredRow = Math.min(dropRowIndex, maxRows);
    
    // Determine preferred column based on drop X position
    // First calculate the potential column positions in a typical 3-column row
    const totalRowWidth = playAreaWidth - (2 * margin); // Width available for all vessels in a row
    const columnWidth = totalRowWidth / 3; // Width of each column
    
    // Calculate the starting X position for a standard row
    const startX = playAreaX + margin;
    
    // Calculate the relative drop X position
    const relativeDropX = dropX - startX;
    
    // Determine the column (0 = left, 1 = center, 2 = right)
    let preferredColumn = 0; // Default to left column
    
    if (relativeDropX >= 0 && relativeDropX <= totalRowWidth) {
      // Within the grid area
      preferredColumn = Math.floor(relativeDropX / columnWidth);
    } else if (relativeDropX > totalRowWidth) {
      // Beyond the right edge
      preferredColumn = 2; // Right column
    }
    
    // For advanced vessels, prevent them from being assigned to the center column (column 1)
    // This ensures they will span columns 0-1 or 1-2 instead of staying centered
    if (newVessel.isAdvanced && preferredColumn === 1) {
      // Calculate the center of the play area
      const centerX = playAreaX + playAreaWidth / 2;
      
      // Shift the vessel left or right based on which side of center it was dropped
      if (dropX < centerX) {
        // If dropped left of center, assign to column 0 (will span 0-1)
        newVessel.preferredColumn = 0;
        console.log("Advanced vessel shifted from center to left column (will span 0-1)");
      } else {
        // If dropped right of center, assign to column 2 (will span 1-2)
        newVessel.preferredColumn = 2;
        console.log("Advanced vessel shifted from center to right column (will span 1-2)");
      }
    } else {
      // For basic vessels or advanced vessels already in columns 0 or 2, keep the original column
      newVessel.preferredColumn = preferredColumn;
    }
    
    // Add column boundary information for better visualization
    const colBoundaries = [
      startX,                          // Left edge of left column
      startX + columnWidth,            // Left edge of center column
      startX + 2 * columnWidth,        // Left edge of right column
      startX + 3 * columnWidth         // Right edge of right column
    ];
    
    // Enhanced logging to verify function execution
    console.log("=== PREFERRED POSITION ASSIGNMENT ===");
    console.log(`Drop position: X=${dropX}, Y=${dropY}`);
    console.log(`Play area start: X=${startX}, Y=${startY}`);
    console.log(`Column width: ${columnWidth}, Row height: ${rowHeight}`);
    console.log(`Relative drop position: X=${relativeDropX}, Y=${relativeDropY}`);
    console.log(`Column boundaries: [${colBoundaries.join(', ')}]`);
    console.log(`Calculated position: Row=${dropRowIndex}, Column=${preferredColumn}`);
    console.log(`Assigned position: Row=${newVessel.preferredRow}, Column=${newVessel.preferredColumn}`);
    console.log(`New vessel properties:`, newVessel.name || "unnamed", newVessel.ingredients);
    console.log("====================================");
  }
  
  function arrangeVessels() {
    // Calculate vessel sizes based on play area width to ensure 3 base vessels per row
    // We need to fit 3 vessels plus margins in the play area width
    // Convert fixed margins to relative values based on play area dimensions
    let margin = playAreaWidth * 0.0125; // 1.25% of play area width (was 10px)
    let vertical_margin = playAreaHeight * 0.008; // 0.8% of play area height (was 5px)
    
    // Ensure minimum values for very small screens
    margin = Math.max(margin, 3); // Minimum 3px margin
    vertical_margin = Math.max(vertical_margin, 2); // Minimum 2px vertical margin
    
    // Calculate basic vessel width to fit exactly 3 per row with margins
    let basic_w = (playAreaWidth - (4 * margin)) / 3; // 3 vessels with margin on both sides
    let basic_h = basic_w * 0.8; // Maintain aspect ratio
    
    // Advanced vessels are twice as wide
    let advanced_w = basic_w * 2 + margin;
    let advanced_h = basic_h * 1.2;
    
    // Calculate column widths and positions for precise column preferences
    const columnWidth = (playAreaWidth - (4 * margin)) / 3;
    const columnPositions = [
      playAreaX + margin + columnWidth/2,                // Left column center
      playAreaX + margin + columnWidth + margin + columnWidth/2,  // Middle column center
      playAreaX + margin + 2 * (columnWidth + margin) + columnWidth/2 // Right column center
    ];

    // Calculate the starting Y position
    let startY = playAreaY + playAreaHeight * 0.2;
    
    // Find vessel with preferredRow (if any)
    const preferredVessel = vessels.find(v => v.hasOwnProperty('preferredRow'));
    
    // Log debugging information about the preferred vessel
    if (preferredVessel) {
      console.log("=== ARRANGE VESSELS ===");
      console.log("Found vessel with preferred position:", 
                  { row: preferredVessel.preferredRow, column: preferredVessel.preferredColumn || 'not set' });
      console.log("Vessel properties:", preferredVessel.name || "unnamed", preferredVessel.ingredients);
      console.log("======================");
    }
    
    // ENHANCEMENT 1: Sort vessels by priority - colored vessels should move less than base vessels
    // Sort order: 1) Advanced (colored) vessels first, 2) Basic (white) vessels
    // This ensures we position colored vessels first and move basic vessels around them
    let advancedVessels = vessels
      .filter(v => v.isAdvanced && v !== preferredVessel)
      .sort((a, b) => {
        // Sort by complexity (number of ingredients) in descending order
        return b.ingredients.length - a.ingredients.length;
      });
      
    let basicVessels = vessels
      .filter(v => !v.isAdvanced && v !== preferredVessel)
      .sort((a, b) => {
        // Sort by complexity (number of ingredients) in descending order
        return b.ingredients.length - a.ingredients.length;
      });
    
    // Create an array to hold our row arrangements
    let rowArrangements = [];
    
    // Handle preferred vessel placement logic
    if (preferredVessel) {
      const preferredRow = preferredVessel.preferredRow;
      
      // Helper function to create a standard row
      const createStandardRow = () => {
        let row = [];
        if (advancedVessels.length > 0 && basicVessels.length > 0) {
          row.push(advancedVessels.shift());
          row.push(basicVessels.shift());
        } else if (advancedVessels.length > 0) {
          row.push(advancedVessels.shift());
        } else if (basicVessels.length > 0) {
          for (let i = 0; i < 3 && basicVessels.length > 0; i++) {
            row.push(basicVessels.shift());
          }
        }
        return row;
      };
      
      // Fill rows until we reach the preferred row
      while (rowArrangements.length < preferredRow && 
            (advancedVessels.length > 0 || basicVessels.length > 0)) {
        rowArrangements.push(createStandardRow());
      }
      
      // Create the preferred row with the preferred vessel
      let preferredRowArr = [];
      
      // ENHANCEMENT 2: Honor column preference when placing the vessel
      if (preferredVessel.hasOwnProperty('preferredColumn')) {
        // We need to create a row that places the vessel in the correct column
        const preferredColumn = preferredVessel.preferredColumn;
        
        // For a vessel in column 0, it should be the first vessel in the row
        // For a vessel in column 1, it should be the second vessel (or first if it's advanced)
        // For a vessel in column 2, it should be the third vessel (or second if there's an advanced first)
        
        console.log(`Creating row with vessel in preferred column ${preferredColumn}`);
        
        // Initialize the row with null placeholders
        preferredRowArr = [null, null, null];
        
        // Place the preferred vessel at its column position
        preferredRowArr[preferredColumn] = preferredVessel;
        
        // Now fill the remaining positions with the most appropriate vessels
        if (preferredVessel.isAdvanced) {
          // Advanced vessel takes 2 slots, so we can only add one more basic vessel
          // If it's in column 0, we can add a basic vessel in column 2
          // If it's in column 1, we can't add any more vessels
          // If it's in column 2, we can add a basic vessel in column 0
          if (preferredColumn === 0 && basicVessels.length > 0) {
            preferredRowArr[2] = basicVessels.shift();
          } else if (preferredColumn === 2 && basicVessels.length > 0) {
            preferredRowArr[0] = basicVessels.shift();
          }
        } else {
          // Basic vessel takes 1 slot, so we can add more vessels
          if (preferredColumn === 0) {
            // We can add an advanced vessel in column 1 or two basic vessels in column 1 and 2
            if (advancedVessels.length > 0) {
              preferredRowArr[1] = advancedVessels.shift();
            } else {
              if (basicVessels.length > 0) preferredRowArr[1] = basicVessels.shift();
              if (basicVessels.length > 0) preferredRowArr[2] = basicVessels.shift();
            }
          } else if (preferredColumn === 1) {
            // We can add one basic vessel in column 0 and one in column 2
            if (basicVessels.length > 0) preferredRowArr[0] = basicVessels.shift();
            if (basicVessels.length > 0) preferredRowArr[2] = basicVessels.shift();
          } else if (preferredColumn === 2) {
            // We can add an advanced vessel in column 0 or two basic vessels in column 0 and 1
            if (advancedVessels.length > 0) {
              preferredRowArr[0] = advancedVessels.shift();
            } else {
              if (basicVessels.length > 0) preferredRowArr[0] = basicVessels.shift();
              if (basicVessels.length > 0) preferredRowArr[1] = basicVessels.shift();
            }
          }
        }
        
        // Filter out null placeholders
        preferredRowArr = preferredRowArr.filter(v => v !== null);
      } else {
        // No column preference, just place the vessel at the start of the row
        preferredRowArr = [preferredVessel];
        
        // Determine how many more slots we can fill in this row
        let slotsAvailable = preferredVessel.isAdvanced ? 1 : 2; // Advanced takes 2 slots, basic takes 1
        
        // Fill remaining slots in the preferred row
        if (slotsAvailable > 0) {
          if (slotsAvailable === 1) {
            // We can fit one basic vessel
            if (basicVessels.length > 0) {
              preferredRowArr.push(basicVessels.shift());
            }
          } else if (slotsAvailable === 2) {
            // We can fit either one advanced or up to two basic vessels
            if (advancedVessels.length > 0) {
              preferredRowArr.push(advancedVessels.shift());
            } else {
              for (let i = 0; i < 2 && basicVessels.length > 0; i++) {
                preferredRowArr.push(basicVessels.shift());
              }
            }
          }
        }
      }
      
      rowArrangements.push(preferredRowArr);
    }
    
    // Continue with regular arrangement for remaining vessels
    while (advancedVessels.length > 0 || basicVessels.length > 0) {
      let currentRow = [];
      
      // Try to create rows with 1 advanced vessel and 1 basic vessel when possible
      if (advancedVessels.length > 0 && basicVessels.length > 0) {
        currentRow.push(advancedVessels.shift()); // Add 1 advanced vessel (takes 2 slots)
        currentRow.push(basicVessels.shift()); // Add 1 basic vessel (takes 1 slot)
        rowArrangements.push(currentRow);
      }
      // If we only have advanced vessels left, add 1 per row
      else if (advancedVessels.length > 0) {
        currentRow.push(advancedVessels.shift());
        rowArrangements.push(currentRow);
      }
      // If we only have basic vessels left, add 3 per row (or fewer if that's all we have)
      else if (basicVessels.length > 0) {
        // Add up to 3 basic vessels
        for (let i = 0; i < 3 && basicVessels.length > 0; i++) {
          currentRow.push(basicVessels.shift());
        }
        rowArrangements.push(currentRow);
      }
    }

    // Position all vessels based on row arrangements
    rowArrangements.forEach((row, rowIndex) => {
      // Calculate total width of this row
      let rowWidth = row.reduce((width, v) => {
        return width + (v.isAdvanced ? advanced_w : basic_w);
      }, 0) + (row.length - 1) * margin;

      // Calculate starting x position to center the row within the play area
      let startX = playAreaX + (playAreaWidth - rowWidth) / 2;
      let currentX = startX;

      // Position each vessel in the row
      row.forEach((v, columnIndex) => {
        // Update vessel dimensions
        if (v.isAdvanced) {
          v.w = advanced_w;
          v.h = advanced_h;
        } else {
          v.w = basic_w;
          v.h = basic_h;
        }

        // ENHANCEMENT 3: For vessels with preferred column, try to honor that position
        if (v.hasOwnProperty('preferredColumn') && v === preferredVessel) {
          // Calculate the x-coordinate based on the column preference
          const preferredColumn = v.preferredColumn;
          
          // Determine the position for the vessel based on its type and preferred column
          let preferredX;
          
          if (v.isAdvanced) {
            // Check if this vessel is the only one in its row - if so, center it
            if (row.length === 1) {
              // For a single advanced vessel in a row, center it in the middle of the play area
              preferredX = playAreaX + playAreaWidth / 2;
              console.log("Single advanced vessel in row - centering in play area");
            } else {
              // Advanced vessels should span two columns
              if (preferredColumn === 0) {
                // Left column drop: position between columns 0 and 1
                preferredX = playAreaX + margin + columnWidth + margin/2;
              } else if (preferredColumn === 2) {
                // Right column drop: position between columns 1 and 2
                preferredX = playAreaX + margin + columnWidth + margin + columnWidth + margin/2;
              } else if (preferredColumn === 1) {
                // Center column drop: deterministically choose column based on position in row
                // Use columnIndex to alternate between spanning 0-1 and 1-2
                // This ensures a more balanced and predictable grid layout
                if (columnIndex % 2 === 0) {
                  // For first vessel in row or even indexed vessels, span columns 0-1
                  preferredX = playAreaX + margin + columnWidth + margin/2;
                  console.log("Center vessel positioned to span columns 0-1");
                } else {
                  // For odd indexed vessels, span columns 1-2
                  preferredX = playAreaX + margin + columnWidth + margin + columnWidth + margin/2;
                  console.log("Center vessel positioned to span columns 1-2");
                }
              }
            }
          } else {
            // Basic vessels still use the column centers
            preferredX = columnPositions[preferredColumn];
          }
          
          // Log that we're positioning at the preferred column
          console.log(`Positioning vessel at preferred column ${preferredColumn} (x=${preferredX})`);
          console.log(`Vessel is ${v.isAdvanced ? 'advanced' : 'basic'} and spans ${v.isAdvanced ? '2 columns' : '1 column'}`);
          
          // Set vessel position
          v.x = preferredX;
          v.y = startY + rowIndex * (basic_h + vertical_margin);
          v.originalX = v.x;
          v.originalY = v.y;
          
          // Adjust currentX to account for this vessel's placement
          currentX = v.x + v.w/2 + margin;
        } else {
          // For vessels without a specific column preference, just place them sequentially
          // Set vessel position
          v.x = currentX + v.w / 2;
          v.y = startY + rowIndex * (basic_h + vertical_margin); // Use basic_h for consistent spacing
          v.originalX = v.x;
          v.originalY = v.y;
          
          // Move x position for next vessel
          currentX += v.w + margin;
        }
      });
    });
    
    // Calculate the lowest vessel position for hint button placement
    let lowestY = startY;
    vessels.forEach(v => {
      lowestY = Math.max(lowestY, v.y + v.h/2);
    });
    
    // If initial hint button position is not set (first time), calculate it
    // Otherwise, use the stored position
    if (!initialHintButtonY) {
      // Set hint button at a fixed position from bottom of screen
      hintButtonY = height - 150; // 150px from bottom of screen
      
      // Store the initial hint button position
      initialHintButtonY = hintButtonY;
    } else {
      // Use the stored initial position
      hintButtonY = initialHintButtonY;
    }
    
    // Calculate button dimensions using relative values
    // Hint button - smaller action button
    let buttonWidth = playAreaWidth * 0.15; // 15% of play area width (was 120px)
    let buttonHeight = buttonWidth * 0.333; // Maintain aspect ratio
    // Ensure minimum sizes for usability
    buttonWidth = Math.max(buttonWidth, 80);
    buttonHeight = Math.max(buttonHeight, 30);
    
    // Start button - larger call to action
    let startButtonWidth = playAreaWidth * 0.2; // 20% of play area width (was 30%)
    let startButtonHeight = startButtonWidth * 0.4; // Maintain aspect ratio
    // Enforce minimum sizes
    startButtonWidth = Math.max(startButtonWidth, 100);
    startButtonHeight = Math.max(startButtonHeight, 40);
    
    // Create hint button with white background and grey outline
    hintButton = new Button(
      playAreaX + playAreaWidth * 0.5, // Center horizontally
      hintButtonY, 
      buttonWidth, 
      buttonHeight, 
      "Hint", 
      showHint, 
      'white', 
      '#FF5252'
    );
    
    // Create start button
    startButton = new Button(
      playAreaX + playAreaWidth * 0.5, // Center horizontally
      playAreaY + playAreaHeight * 0.85, // Position at 85% down the play area
      startButtonWidth, 
      startButtonHeight, 
      "Cook!", 
      startGame, 
      COLORS.secondary, 
      'white'
    );
    
    // After arrangement, log the final position of the preferred vessel
    if (preferredVessel) {
      // Calculate the grid column based on position
      const minX = playAreaX;
      const maxX = playAreaX + playAreaWidth;
      const columnWidth = (maxX - minX) / 3;
      
      // Determine which grid column the vessel ended up in
      let vesselColumn;
      if (preferredVessel.x < minX + columnWidth) {
        vesselColumn = 0; // Left column
      } else if (preferredVessel.x < minX + 2 * columnWidth) {
        vesselColumn = 1; // Center column
      } else {
        vesselColumn = 2; // Right column
      }
      
      // Check if we successfully honored the vessel's preferred position
      const preferredColumnHonored = !preferredVessel.hasOwnProperty('preferredColumn') || 
                                   vesselColumn === preferredVessel.preferredColumn;
      const preferredRowHonored = Math.floor((preferredVessel.y - startY) / (basic_h + vertical_margin)) === preferredVessel.preferredRow;
      
      console.log("=== VESSEL POSITIONED ===");
      console.log("Final position of vessel with preferred position:", {x: preferredVessel.x, y: preferredVessel.y});
      console.log("Grid position:", 
                  {row: Math.floor((preferredVessel.y - startY) / (basic_h + vertical_margin)), 
                   column: vesselColumn});
      console.log("Preferred position was:", 
                  {row: preferredVessel.preferredRow, column: preferredVessel.preferredColumn || 'not set'});
      console.log("Position honored:", {row: preferredRowHonored, column: preferredColumnHonored});
      console.log("========================");
      
      // Clear the preferences after using them
      delete preferredVessel.preferredRow;
      delete preferredVessel.preferredColumn;
    }
  }
  